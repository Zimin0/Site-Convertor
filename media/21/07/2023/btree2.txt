#include <iostream>
#include <vector>
#include <random>
#include <algorithm>

const int MAX_KEYS = 4;

struct Node {
    std::vector<int> keys;
    std::vector<Node*> children;
    Node* parent;
    bool is_leaf;

    Node() : parent(nullptr), is_leaf(false) {}

    bool is_full() const {
        return keys.size() >= MAX_KEYS;
    }
};

class BPlusTree {
public:
    BPlusTree() : root(nullptr) {}

    void insert(int key) {
        if (root == nullptr) {
            root = create_node();
            root->is_leaf = true;
        }
        Node* node = root;
        while (!node->is_leaf) {
            int child_index = find_child_index(node, key);
            if (node->children[child_index]->is_full()) {
                split_child(node, child_index);
                if (key > node->keys[child_index])
                    child_index++;
            }
            node = node->children[child_index];
        }
        insert_into_leaf(node, key);
    }

    void print_tree() {
        if (root == nullptr) {
            std::cout << "Empty tree" << std::endl;
            return;
        }
        print_node(root, 0);
    }

    void inorder_traversal() {
        if (root == nullptr) {
            return;
        }
        inorder_traversal_recursive(root);
    }

    int find_closest_key_above(int key) {
        if (root == nullptr) {
            return -1;
        }
        Node* leaf = find_leaf(root, key);
        int index = find_key_index(leaf, key);
        if (index < leaf->keys.size() - 1) {
            return leaf->keys[index + 1];
        } else {
            Node* node = leaf->parent;
            while (node != nullptr) {
                index = find_key_index(node, key);
                if (index < node->keys.size() - 1) {
                    return node->keys[index + 1];
                }
                node = node->parent;
            }
        }
        return -1;
    }

private:
    Node* root;

    Node* create_node() {
        return new Node();
    }

    void insert_into_leaf(Node* node, int key) {
        auto it = std::lower_bound(node->keys.begin(), node->keys.end(), key);
        node->keys.insert(it, key);
    }

    void split_child(Node* parent, int child_index) {
        Node* child = parent->children[child_index];
        Node* new_node = create_node();
        new_node->is_leaf = child->is_leaf;

        parent->keys.insert(parent->keys.begin() + child_index, child->keys[MAX_KEYS / 2]);
        parent->children.insert(parent->children.begin() + child_index + 1, new_node);

        for (int i = MAX_KEYS / 2 + 1; i < child->keys.size(); i++) {
            new_node->keys.push_back(child->keys[i]);
        }
        child->keys.resize(MAX_KEYS / 2 + 1);

        if (!child->is_leaf) {
            for (int i = MAX_KEYS / 2 + 1; i < child->children.size(); i++) {
                new_node->children.push_back(child->children[i]);
                child->children[i]->parent = new_node;
            }
            child->children.resize
